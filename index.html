<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Карта тривог — Дніпропетровська область (спрощена)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html,body,#map{height:100%;margin:0}
    #map{height:100vh}
    .legend{background:#fff;padding:10px;border-radius:8px;box-shadow:0 0 6px rgba(0,0,0,.12);line-height:1.4}
    .legend span{display:inline-block;width:14px;height:14px;margin-right:6px}
    .topbar{position:absolute;z-index:1000;left:12px;top:12px;background:#fff;border-radius:8px;padding:8px 10px;box-shadow:0 0 6px rgba(0,0,0,.12)}
    .muted{color:#6b7280;font-size:.9em}
  </style>
</head>
<body>
  <div class="topbar">
    <div><strong>Дніпропетровська область</strong> — статус тривоги</div>
    <div class="muted">дані з API (оновлення кожні 30с)</div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // ---------- Налаштування ----------
    const MAP_CENTER = [48.4647, 35.0462]; // Дніпро
    const MAP_ZOOM = 8;

    // Джерело меж областей України (GeoJSON)
    // Файл містить усі області; ми відфільтруємо Дніпропетровську
    const UKR_OBLASTS_GEOJSON = "https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/ukraine-oblasts.geojson";

    // API активних тривог для області (потрібен токен)
    // Замініть YOUR_APP_TOKEN на свій токен alerts.in.ua або інший сумісний endpoint
    const ALERTS_API_URL = "https://api.alerts.in.ua/v1/regions/9/alerts/active.json?token=YOUR_APP_TOKEN"; // uid=9 — Дніпропетровська обл.

    const COLORS = {
      ok:   '#4CAF50', // немає тривоги
      warn: '#E53935', // активна тривога
      unk:  '#9E9E9E'  // невідомо
    };

    // ---------- Карта ----------
    const map = L.map('map').setView(MAP_CENTER, MAP_ZOOM);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: '© OpenStreetMap'
    }).addTo(map);

    let oblastLayer = null;

    // Завантажуємо всі області та лишаємо Дніпропетровську
    fetch(UKR_OBLASTS_GEOJSON)
      .then(r => r.json())
      .then(all => {
        const dnipro = {
          type: 'FeatureCollection',
          features: (all.features || []).filter(f => {
            const n = (f.properties && (f.properties.name || f.properties.NAME || f.properties.na_ua)) || '';
            return /Dnipropetrovsk/i.test(n) || /Дніпропетров/i.test(n);
          })
        };
        if (!dnipro.features.length) throw new Error('Не знайдено полігон області у файлі меж');

        oblastLayer = L.geoJSON(dnipro, {
          style: { weight: 2, color: '#333', fillColor: COLORS.unk, fillOpacity: .55 }
        }).addTo(map);
        try { map.fitBounds(oblastLayer.getBounds(), { padding: [20,20] }); } catch(e){}

        // після додавання шару — підтягуємо статус тривоги
        refreshAlert();
        setInterval(refreshAlert, 30_000);
      })
      .catch(err => {
        console.error('Помилка завантаження меж областей:', err);
        alert('Не вдалося завантажити межі області. Спробуйте відкрити сторінку через http(s)://, не file://');
      });

    function setOblastColor(status){
      if(!oblastLayer) return;
      const fillColor = status === 'alert' ? COLORS.warn : status === 'ok' ? COLORS.ok : COLORS.unk;
      oblastLayer.setStyle({ fillColor });
    }

    async function refreshAlert(){
      try {
        const r = await fetch(ALERTS_API_URL, { cache: 'no-store' });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const data = await r.json();
        // Просте правило: якщо масив активних тривог непорожній — ставимо стан alert
        const active = Array.isArray(data) ? data.length > 0 : !!(data && (data.active || data.alerts && data.alerts.length));
        setOblastColor(active ? 'alert' : 'ok');
      } catch(e){
        console.warn('Не вдалося отримати статус тривоги, ставлю невідомо', e);
        setOblastColor('unk');
      }
    }

    // Легенда
    const legend = L.control({position:'bottomright'});
    legend.onAdd = () => {
      const div = L.DomUtil.create('div','legend');
      div.innerHTML = `
        <div><span style="background:${COLORS.ok}"></span> Немає тривоги</div>
        <div><span style="background:${COLORS.warn}"></span> Активна тривога</div>
        <div><span style="background:${COLORS.unk}"></span> Невідомо</div>
      `;
      return div;
    };
    legend.addTo(map);
  </script>
</body>
</html>
        const since = getDistrictAlertSince(name) || '';

        const html = `
          <div class="info">
            <strong>${name || '—'}</strong><br/>
            Статус: <strong>${status === 'alert' ? 'Тривога' : status === 'no_alert' ? 'Немає тривоги' : 'Невідомо'}</strong><br/>
            ${since ? 'Почалося: ' + new Date(since).toLocaleString() : ''}
          </div>
        `;

        L.popup().setLatLng(layer.getBounds().getCenter()).setContent(html).openOn(map);
      });
    }

    // Загрузить тревоги и применить к районам
    function loadAlertsAndStyle(){
      // Попытка получить промежуточный формат тревог: маппинг по названиям районов
      fetch(ALERTS_API_URL).then(r => r.json()).then(raw => {
        // Преобразуй raw в формат [{district_name, status, since}, ...]
        alertsData = mapAlertsToDistricts(raw);

        // Применяем стили: проходим по всем фичам GeoJSON
        districtsLayer.eachLayer(layer => {
          const feat = layer.feature;
          const name = feat.properties && (feat.properties.name || feat.properties.NA_UA || feat.properties.NAME);
          const status = getDistrictStatusByName(name) || 'no_alert';
          applyStyleToFeature(layer, status);
        });
      }).catch(err => {
        console.error('Ошибка получения тревог:', err);
      });
    }

    // Пример функции: преобразует ответ API в единый массив объектов.
    // Здесь мы даём несколько стратегий сопоставления — по district_name, по uid и т.д.
    function mapAlertsToDistricts(raw){
      // Если API alerts.in.ua вернул структуру, содержащую items с oblasts/regions,
      // то нужно адаптировать эту функцию. Здесь — пример общего преобразования.

      // Пример: если API возвращает массив с полями 'region', 'raion' или 'settlement'
      // тогда нужно собрать status для каждого raion.

      try{
        // если raw уже в нужном формате — вернуть
        if(Array.isArray(raw) && raw.length && raw[0].district_name) return raw;

        // Простейшая попытка: искать вложенные alerts по районам
        const out = [];

        // Если raw имеет поле 'items' или 'alerts'
        const candidates = raw.items || raw.alerts || raw;

        if(Array.isArray(candidates)){
          candidates.forEach(it => {
            // Попробуем найти имя района
            const name = it.raion || it.district || it.district_name || it.name || (it.region && it.region.name);
            if(!name) return;
            // Решим статус (примерное правило)
            const status = (it.status && it.status === 'active') || (it.alert && it.alert === true) ? 'alert' : 'no_alert';
            const since = it.since || it.started_at || it.time || null;
            out.push({district_name: name, status, since});
          });
        }
        return out;
      }catch(e){
        console.warn('Не удалось распарсить тревоги автоматически', e);
        return [];
      }
    }

    // Поиск статуса района по имени (учитывает небольшие расхождения регистра)
    function getDistrictStatusByName(name){
      if(!name || !alertsData) return null;
      const find = alertsData.find(a => a.district_name && a.district_name.toLowerCase() === name.toLowerCase());
      return find ? find.status : null;
    }

    function getDistrictAlertSince(name){
      if(!name || !alertsData) return null;
      const find = alertsData.find(a => a.district_name && a.district_name.toLowerCase() === name.toLowerCase());
      return find ? find.since : null;
    }

    // Простая auto-refresh каждые 30 секунд
    setInterval(() => {
      if(districtsLayer) loadAlertsAndStyle();
    }, 30_000);

    // ---------- Легенда ----------
    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function(){
      const div = L.DomUtil.create('div','legend');
      div.innerHTML = `
        <div><span style="background:${COLORS.no_alert}"></span> Немає тривоги</div>
        <div><span style="background:${COLORS.alert}"></span> Активна тривога</div>
        <div><span style="background:${COLORS.unknown}"></span> Невідомо</div>
      `;
      return div;
    };
    legend.addTo(map);

    // ---------- Утилиты и примечания для разработчика ----------
    /*
      Что нужно подготовить перед размещением на сайте:
      1) dnipro_districts.geojson — GeoJSON с полигонами районов/громад Дніпропетровської області.
         Поля feature.properties.name или NA_UA должны содержать человеко-понятное имя района.
      2) ALERTS_API_URL — заменить на реальный endpoint. Если используешь alerts.in.ua, изучи
         их API (devs.alerts.in.ua). В большинстве случаев потребуется API token.
      3) Если API возвращает в ответе идентификаторы районов (uid), то в GeoJSON можно добавить
         свойство properties.uid и тогда в коде делать сопоставление по uid (по-надежнее,
         чем по имени).

      Формат ожидаемый для alertsData: массив объектов {district_name, status, since}.
      При необходимости мы можем добавить fuzzy-matching (например, приводить
      имена к одному виду или хранить сопоставительную таблицу {geojson_name: api_name}.
    */

  </script>
</body>
</html>

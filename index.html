<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Карта тривог — Дніпропетровська область</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html,body,#map{height:100%;margin:0}
    #map{height:100vh}
    .legend{background:#fff;padding:10px;line-height:1.5em;border-radius:8px;box-shadow:0 0 6px rgba(0,0,0,.15)}
    .legend span{display:inline-block;width:14px;height:14px;margin-right:6px}
    .info{background:#fff;padding:8px;border-radius:6px;box-shadow:0 0 6px rgba(0,0,0,.12)}
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // ---------- Настройки ----------
    // Центр и zoom для Дніпропетровської області
    const MAP_CENTER = [48.5, 35.0];
    const MAP_ZOOM = 8;

    // Пути к файлам (замени на реальные URL/путь в проекте)
    // 1) GeoJSON с район/громадами Дніпропетровської області
    //    Подсказка: возьми детальный GeoJSON с административными границами (raions/hromadas)
    //    и помести рядом с сайтом как dnipro_districts.geojson
    const DISTRICTS_GEOJSON_URL = './dnipro_districts.geojson';

    // 2) Endpoint с данными по тревогам для районов.
    //    ВАЖНО: формат ответа ожидается как массив объектов вида:
    //    [{"district_name":"Dnipro","status":"alert","since":"2025-09-25T12:34:00Z"}, ...]
    //    Если API возвращает другие поля — поменяй соответствие в mapAlertToDistrict().
    const ALERTS_API_URL = 'https://api.alerts.in.ua/v1/regions/9/alerts/active.json?token=YOUR_APP_TOKEN';

    // Цвета по статусу
    const COLORS = {
      'no_alert': '#4CAF50', // зелёный
      'alert': '#E53935',    // красный
      'unknown': '#9E9E9E'   // серый
    };

    // ---------- Инициализация карты ----------
    const map = L.map('map').setView(MAP_CENTER, MAP_ZOOM);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: '© OpenStreetMap'
    }).addTo(map);

    // Контейнеры
    let districtsLayer;
    let districtsData = null;
    let alertsData = null;

    // Загрузка GeoJSON с районами
    fetch(DISTRICTS_GEOJSON_URL)
      .then(r => r.json())
      .then(geojson => {
        districtsData = geojson;

        // Создаём слой и добавляем на карту
        districtsLayer = L.geoJSON(districtsData, {
          style: d => defaultStyle(d),
          onEachFeature: onEachDistrict
        }).addTo(map);

        // Подгружаем текущие тревоги и применяем стили
        loadAlertsAndStyle();

        // Центруем карту по областному полигону, если есть bounds
        try { map.fitBounds(districtsLayer.getBounds(), {padding:[20,20]}); } catch(e){/*ignore*/}
      })
      .catch(err => {
        console.error('Ошибка загрузки GeoJSON районов:', err);
        alert('Не удалось загрузить файл dnipro_districts.geojson. Помести его рядом с сайтом.');
      });

    // Простейший стиль по умолчанию
    function defaultStyle(feature){
      return {
        weight: 1,
        color: '#444',
        fillColor: COLORS.no_alert,
        fillOpacity: 0.6
      };
    }

    // Применить стили для района в зависимости от статуса
    function applyStyleToFeature(layer, status){
      const color = status === 'alert' ? COLORS.alert : (status === 'no_alert' ? COLORS.no_alert : COLORS.unknown);
      layer.setStyle({fillColor: color});
    }

    // Обработчик для каждого района
    function onEachDistrict(feature, layer){
      const name = feature.properties && (feature.properties.name || feature.properties.NA_UA || feature.properties.NAME);
      layer.bindTooltip(name || 'Назва відсутня', {sticky:true});

      layer.on('click', () => {
        const props = feature.properties || {};
        const status = getDistrictStatusByName(name) || 'unknown';
        const since = getDistrictAlertSince(name) || '';

        const html = `
          <div class="info">
            <strong>${name || '—'}</strong><br/>
            Статус: <strong>${status === 'alert' ? 'Тривога' : status === 'no_alert' ? 'Немає тривоги' : 'Невідомо'}</strong><br/>
            ${since ? 'Почалося: ' + new Date(since).toLocaleString() : ''}
          </div>
        `;

        L.popup().setLatLng(layer.getBounds().getCenter()).setContent(html).openOn(map);
      });
    }

    // Загрузить тревоги и применить к районам
    function loadAlertsAndStyle(){
      // Попытка получить промежуточный формат тревог: маппинг по названиям районов
      fetch(ALERTS_API_URL).then(r => r.json()).then(raw => {
        // Преобразуй raw в формат [{district_name, status, since}, ...]
        alertsData = mapAlertsToDistricts(raw);

        // Применяем стили: проходим по всем фичам GeoJSON
        districtsLayer.eachLayer(layer => {
          const feat = layer.feature;
          const name = feat.properties && (feat.properties.name || feat.properties.NA_UA || feat.properties.NAME);
          const status = getDistrictStatusByName(name) || 'no_alert';
          applyStyleToFeature(layer, status);
        });
      }).catch(err => {
        console.error('Ошибка получения тревог:', err);
      });
    }

    // Пример функции: преобразует ответ API в единый массив объектов.
    // Здесь мы даём несколько стратегий сопоставления — по district_name, по uid и т.д.
    function mapAlertsToDistricts(raw){
      // Если API alerts.in.ua вернул структуру, содержащую items с oblasts/regions,
      // то нужно адаптировать эту функцию. Здесь — пример общего преобразования.

      // Пример: если API возвращает массив с полями 'region', 'raion' или 'settlement'
      // тогда нужно собрать status для каждого raion.

      try{
        // если raw уже в нужном формате — вернуть
        if(Array.isArray(raw) && raw.length && raw[0].district_name) return raw;

        // Простейшая попытка: искать вложенные alerts по районам
        const out = [];

        // Если raw имеет поле 'items' или 'alerts'
        const candidates = raw.items || raw.alerts || raw;

        if(Array.isArray(candidates)){
          candidates.forEach(it => {
            // Попробуем найти имя района
            const name = it.raion || it.district || it.district_name || it.name || (it.region && it.region.name);
            if(!name) return;
            // Решим статус (примерное правило)
            const status = (it.status && it.status === 'active') || (it.alert && it.alert === true) ? 'alert' : 'no_alert';
            const since = it.since || it.started_at || it.time || null;
            out.push({district_name: name, status, since});
          });
        }
        return out;
      }catch(e){
        console.warn('Не удалось распарсить тревоги автоматически', e);
        return [];
      }
    }

    // Поиск статуса района по имени (учитывает небольшие расхождения регистра)
    function getDistrictStatusByName(name){
      if(!name || !alertsData) return null;
      const find = alertsData.find(a => a.district_name && a.district_name.toLowerCase() === name.toLowerCase());
      return find ? find.status : null;
    }

    function getDistrictAlertSince(name){
      if(!name || !alertsData) return null;
      const find = alertsData.find(a => a.district_name && a.district_name.toLowerCase() === name.toLowerCase());
      return find ? find.since : null;
    }

    // Простая auto-refresh каждые 30 секунд
    setInterval(() => {
      if(districtsLayer) loadAlertsAndStyle();
    }, 30_000);

    // ---------- Легенда ----------
    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function(){
      const div = L.DomUtil.create('div','legend');
      div.innerHTML = `
        <div><span style="background:${COLORS.no_alert}"></span> Немає тривоги</div>
        <div><span style="background:${COLORS.alert}"></span> Активна тривога</div>
        <div><span style="background:${COLORS.unknown}"></span> Невідомо</div>
      `;
      return div;
    };
    legend.addTo(map);

    // ---------- Утилиты и примечания для разработчика ----------
    /*
      Что нужно подготовить перед размещением на сайте:
      1) dnipro_districts.geojson — GeoJSON с полигонами районов/громад Дніпропетровської області.
         Поля feature.properties.name или NA_UA должны содержать человеко-понятное имя района.
      2) ALERTS_API_URL — заменить на реальный endpoint. Если используешь alerts.in.ua, изучи
         их API (devs.alerts.in.ua). В большинстве случаев потребуется API token.
      3) Если API возвращает в ответе идентификаторы районов (uid), то в GeoJSON можно добавить
         свойство properties.uid и тогда в коде делать сопоставление по uid (по-надежнее,
         чем по имени).

      Формат ожидаемый для alertsData: массив объектов {district_name, status, since}.
      При необходимости мы можем добавить fuzzy-matching (например, приводить
      имена к одному виду или хранить сопоставительную таблицу {geojson_name: api_name}.
    */

  </script>
</body>
</html>

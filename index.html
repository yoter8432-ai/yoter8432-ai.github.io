<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <title>Витяг Дніпропетровських районів (ADM2) → GeoJSON</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; }
    button { padding: .7rem 1rem; border-radius: .6rem; border: 1px solid #ddd; cursor: pointer; }
    pre { background:#f6f8fa; padding:1rem; border-radius:.6rem; overflow:auto }
  </style>
</head>
<body>
  <h1>Створити <code>dnipro_districts.geojson</code></h1>
  <p>Натисни кнопку — з офіційного GeoBoundaries ADM2 буде витягнута тільки Дніпропетровська область і збережена у файл.</p>

  <button id="go">Завантажити файл</button>
  <p id="status"></p>

  <script>
    // Офіційний GeoJSON усіх районів України (ADM2)
    // Джерело: HDX / GeoBoundaries
    const ADM2_URL = "https://geoboundaries.org/gbRequest.html?ISO=UKR&ADM=ADM2"; // редірект на актуальний geojson
    // Деякі версії мають поле adm1_name або shapeGroup для області; підтримуємо обидва варіанти
    const DNIPRO_MATCHES = ["Dnipropetrovska", "Dnipropetrovsk", "Дніпропетровська"];

    const $status = document.getElementById("status");
    document.getElementById("go").onclick = async () => {
      $status.textContent = "Завантаження ADM2…";
      try {
        // 1) Отримуємо весь ADM2 GeoJSON
        const res = await fetch(ADM2_URL, { redirect: "follow" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const all = await res.json();

        // 2) Фільтруємо тільки Дніпропетровську область
        if (!all || !Array.isArray(all.features)) throw new Error("Неочікуваний формат GeoJSON");
        const features = all.features.filter(f => {
          const p = f.properties || {};
          const a1 = (p.adm1_name || p.shapeGroup || p.region || "").toString();
          return DNIPRO_MATCHES.some(s => a1.toLowerCase().includes(s.toLowerCase()));
        });

        if (!features.length) throw new Error("Не знайдено районів Дніпропетровської області у цьому наборі");

        // 3) Нормалізуємо назви та додаємо uid по порядку (можеш замінити на свої)
        const norm = features.map((f, i) => {
          const p = f.properties || {};
          const name = p.shapeName || p.name || p.adm2_name || "Без назви";
          f.properties = { uid: i + 1, name };
          return f;
        });

        const out = { type: "FeatureCollection", features: norm };

        // 4) Скачуємо як файл dnipro_districts.geojson
        const blob = new Blob([JSON.stringify(out)], { type: "application/geo+json" });
        const url = URL.createObjectURL(blob);
        const a = Object.assign(document.createElement("a"), { href: url, download: "dnipro_districts.geojson" });
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);

        $status.textContent = `Готово: ${norm.length} районів збережено у dnipro_districts.geojson`;
      } catch (e) {
        console.error(e);
        $status.textContent = "Помилка: " + e.message;
      }
    };
  </script>
</body>
</html>
        const since = getDistrictAlertSince(name) || '';

        const html = `
          <div class="info">
            <strong>${name || '—'}</strong><br/>
            Статус: <strong>${status === 'alert' ? 'Тривога' : status === 'no_alert' ? 'Немає тривоги' : 'Невідомо'}</strong><br/>
            ${since ? 'Почалося: ' + new Date(since).toLocaleString() : ''}
          </div>
        `;

        L.popup().setLatLng(layer.getBounds().getCenter()).setContent(html).openOn(map);
      });
    }

    // Загрузить тревоги и применить к районам
    function loadAlertsAndStyle(){
      // Попытка получить промежуточный формат тревог: маппинг по названиям районов
      fetch(ALERTS_API_URL).then(r => r.json()).then(raw => {
        // Преобразуй raw в формат [{district_name, status, since}, ...]
        alertsData = mapAlertsToDistricts(raw);

        // Применяем стили: проходим по всем фичам GeoJSON
        districtsLayer.eachLayer(layer => {
          const feat = layer.feature;
          const name = feat.properties && (feat.properties.name || feat.properties.NA_UA || feat.properties.NAME);
          const status = getDistrictStatusByName(name) || 'no_alert';
          applyStyleToFeature(layer, status);
        });
      }).catch(err => {
        console.error('Ошибка получения тревог:', err);
      });
    }

    // Пример функции: преобразует ответ API в единый массив объектов.
    // Здесь мы даём несколько стратегий сопоставления — по district_name, по uid и т.д.
    function mapAlertsToDistricts(raw){
      // Если API alerts.in.ua вернул структуру, содержащую items с oblasts/regions,
      // то нужно адаптировать эту функцию. Здесь — пример общего преобразования.

      // Пример: если API возвращает массив с полями 'region', 'raion' или 'settlement'
      // тогда нужно собрать status для каждого raion.

      try{
        // если raw уже в нужном формате — вернуть
        if(Array.isArray(raw) && raw.length && raw[0].district_name) return raw;

        // Простейшая попытка: искать вложенные alerts по районам
        const out = [];

        // Если raw имеет поле 'items' или 'alerts'
        const candidates = raw.items || raw.alerts || raw;

        if(Array.isArray(candidates)){
          candidates.forEach(it => {
            // Попробуем найти имя района
            const name = it.raion || it.district || it.district_name || it.name || (it.region && it.region.name);
            if(!name) return;
            // Решим статус (примерное правило)
            const status = (it.status && it.status === 'active') || (it.alert && it.alert === true) ? 'alert' : 'no_alert';
            const since = it.since || it.started_at || it.time || null;
            out.push({district_name: name, status, since});
          });
        }
        return out;
      }catch(e){
        console.warn('Не удалось распарсить тревоги автоматически', e);
        return [];
      }
    }

    // Поиск статуса района по имени (учитывает небольшие расхождения регистра)
    function getDistrictStatusByName(name){
      if(!name || !alertsData) return null;
      const find = alertsData.find(a => a.district_name && a.district_name.toLowerCase() === name.toLowerCase());
      return find ? find.status : null;
    }

    function getDistrictAlertSince(name){
      if(!name || !alertsData) return null;
      const find = alertsData.find(a => a.district_name && a.district_name.toLowerCase() === name.toLowerCase());
      return find ? find.since : null;
    }

    // Простая auto-refresh каждые 30 секунд
    setInterval(() => {
      if(districtsLayer) loadAlertsAndStyle();
    }, 30_000);

    // ---------- Легенда ----------
    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function(){
      const div = L.DomUtil.create('div','legend');
      div.innerHTML = `
        <div><span style="background:${COLORS.no_alert}"></span> Немає тривоги</div>
        <div><span style="background:${COLORS.alert}"></span> Активна тривога</div>
        <div><span style="background:${COLORS.unknown}"></span> Невідомо</div>
      `;
      return div;
    };
    legend.addTo(map);

    // ---------- Утилиты и примечания для разработчика ----------
    /*
      Что нужно подготовить перед размещением на сайте:
      1) dnipro_districts.geojson — GeoJSON с полигонами районов/громад Дніпропетровської області.
         Поля feature.properties.name или NA_UA должны содержать человеко-понятное имя района.
      2) ALERTS_API_URL — заменить на реальный endpoint. Если используешь alerts.in.ua, изучи
         их API (devs.alerts.in.ua). В большинстве случаев потребуется API token.
      3) Если API возвращает в ответе идентификаторы районов (uid), то в GeoJSON можно добавить
         свойство properties.uid и тогда в коде делать сопоставление по uid (по-надежнее,
         чем по имени).

      Формат ожидаемый для alertsData: массив объектов {district_name, status, since}.
      При необходимости мы можем добавить fuzzy-matching (например, приводить
      имена к одному виду или хранить сопоставительную таблицу {geojson_name: api_name}.
    */

  </script>
</body>
</html>
